// R√©cup√©rer les adresses de l'utilisateur connect√©
export const getUserAddresses = async (userId) => {
  try {
    console.log('[getUserAddresses] userId re√ßu:', userId);
    const userRef = doc(db, 'users', userId);
    console.log('[getUserAddresses] userRef:', userRef);
    const userSnap = await getDoc(userRef);
    console.log('[getUserAddresses] userSnap exists:', userSnap.exists());
    if (userSnap.exists()) {
      const data = userSnap.data();
      if (typeof window !== 'undefined') {
        window.__LAST_USER_DOC = data;
      }
      console.log('[getUserAddresses] Donn√©es Firestore:', data);
      console.log('[getUserAddresses] Adresses trouv√©es:', data.addresses);
      return data.addresses || [];
    } else {
      console.log('[getUserAddresses] Aucun document trouv√© pour cet userId');
    }
    return [];
  } catch (error) {
    console.error('[getUserAddresses] Erreur:', error);
    return [];
  }
};
import database from './database.js';
import { collection, addDoc, getDocs, doc, updateDoc, deleteDoc, query, where, orderBy, getDoc } from 'firebase/firestore';

console.log('üîß [orders.js] Module charg√©');
console.log('üîß [orders.js] Database import√©:', typeof database);

const { db } = database;

console.log('üîß [orders.js] db extrait:', db);
console.log('üîß [orders.js] Type de db:', typeof db);

// Ajouter une nouvelle commande
export const addOrder = async (orderData) => {
  console.log('üöÄ [orders.js] addOrder appel√©e');
  console.log('üìÑ [orders.js] orderData re√ßue:', orderData);
  console.log('üîç [orders.js] db disponible:', !!db);
  console.log('üîç [orders.js] collection function:', typeof collection);
  console.log('üîç [orders.js] addDoc function:', typeof addDoc);
  
  try {
    console.log('üìù [orders.js] D√©but du processus d\'ajout de commande');
    console.log('üîç [orders.js] V√©rification de db:', db);
    console.log('üîç [orders.js] Type de db:', typeof db);
    
    const orderToAdd = {
      ...orderData,
      createdAt: new Date(),
      updatedAt: new Date(),
      status: 'non-confirm√©' // Statut par d√©faut
    };
    
    console.log('üì¶ [orders.js] Donn√©es de commande pr√©par√©es:', orderToAdd);
    console.log('üöÄ [orders.js] Tentative de cr√©ation de la collection...');
    
    const ordersCollection = collection(db, 'orders');
    console.log('‚úÖ [orders.js] Collection cr√©√©e:', ordersCollection);
    
    console.log('üöÄ [orders.js] Tentative d\'ajout du document...');
    const docRef = await addDoc(ordersCollection, orderToAdd);
    console.log('‚úÖ [orders.js] Document ajout√© avec l\'ID:', docRef.id);
    
    const result = {
      id: docRef.id,
      ...orderToAdd
    };
    
    console.log('üéâ [orders.js] Commande cr√©√©e avec succ√®s:', result);
    return result;
    
  } catch (error) {
    console.error('‚ùå [orders.js] Erreur lors de l\'ajout de la commande:', error);
    console.error('‚ùå [orders.js] Type d\'erreur:', typeof error);
    console.error('‚ùå [orders.js] Message:', error?.message);
    console.error('‚ùå [orders.js] Code:', error?.code);
    console.error('‚ùå [orders.js] Stack trace:', error?.stack);
    throw error;
  }
};

// R√©cup√©rer toutes les commandes
export const getOrders = async () => {
  try {
    console.log('üìñ [orders.js] R√©cup√©ration de toutes les commandes');
    const querySnapshot = await getDocs(collection(db, 'orders'));
    const orders = [];
    
    querySnapshot.forEach((doc) => {
      orders.push({
        id: doc.id,
        ...doc.data()
      });
    });
    if (orders.length > 0) {
      // Log un exemple de commande compl√®te, avec items
      const example = orders[0];
      console.log('[orders.js] Exemple de commande r√©cup√©r√©e:', example);
      if (example.items) {
        console.log('[orders.js] Items de la commande exemple:', example.items);
      }
    }
    console.log('‚úÖ [orders.js] Commandes r√©cup√©r√©es:', orders.length);
    return orders;
  } catch (error) {
    console.error('‚ùå [orders.js] Erreur lors de la r√©cup√©ration des commandes:', error);
    throw error;
  }
};

// R√©cup√©rer les commandes d'un utilisateur sp√©cifique
// R√©cup√©rer uniquement les commandes confirm√©es d'un utilisateur
export const getUserConfirmedOrders = async (userId) => {
  try {
    const ordersCollection = collection(db, 'orders');
    const q = query(
      ordersCollection,
      where('userId', '==', userId),
      where('status', '==', 'confirm√©')
    );
    const querySnapshot = await getDocs(q);
    const orders = [];
    querySnapshot.forEach((doc) => {
      orders.push({
        id: doc.id,
        ...doc.data()
      });
    });
    return orders;
  } catch (error) {
    console.error('[orders.js] Erreur getUserConfirmedOrders:', error);
    throw error;
  }
};
export const getUserOrders = async (userId) => {
  try {
    console.log('üîçüîçüîç [orders.js] ===== D√âBUT getUserOrders =====');
    console.log('üìñ [orders.js] R√©cup√©ration des commandes pour l\'utilisateur:', userId);
    console.log('üìñ [orders.js] Type de userId:', typeof userId);
    console.log('üìñ [orders.js] Valeur exacte userId:', JSON.stringify(userId));
    
    console.log('üîç [orders.js] Construction de la requ√™te filtr√©e directement...');
    const ordersCollection = collection(db, 'orders');
    console.log('‚úÖ [orders.js] Collection orders r√©cup√©r√©e');
    
    // Requ√™te filtr√©e par userId ET statut non-confirm√© (conforme aux r√®gles Firestore)
    const q = query(
      ordersCollection, 
      where('userId', '==', userId),
      where('status', '==', 'non-confirm√©')
    );
    console.log('‚úÖ [orders.js] Requ√™te construite avec where userId ==', userId, 'et status == non-confirm√©');
    
    console.log('üöÄ [orders.js] Ex√©cution de la requ√™te filtr√©e...');
    const querySnapshot = await getDocs(q);
    console.log('‚úÖ [orders.js] Requ√™te ex√©cut√©e, r√©sultats re√ßus');
    console.log('üìä [orders.js] Nombre de documents trouv√©s:', querySnapshot.size);
    console.log('üìä [orders.js] Query snapshot empty?', querySnapshot.empty);
    
    const orders = [];
    let docCount = 0;
    
    querySnapshot.forEach((doc) => {
      docCount++;
      const docData = doc.data();
      console.log(`üìÑ [orders.js] Document ${docCount}:`, {
        id: doc.id,
        userId: docData.userId,
        userEmail: docData.userEmail,
        userName: docData.userName,
        status: docData.status,
        orderNumber: docData.orderNumber,
        total: docData.total,
        createdAt: docData.createdAt
      });
      
      console.log(`üîç [orders.js] Document ${docCount} - Comparaison userId:`);
      console.log(`   - Recherch√©: "${userId}" (type: ${typeof userId})`);
      console.log(`   - Trouv√©: "${docData.userId}" (type: ${typeof docData.userId})`);
      console.log(`   - Match: ${userId === docData.userId}`);
      
      orders.push({
        id: doc.id,
        ...docData
      });
    });
    
    console.log('‚úÖ [orders.js] Tous les documents trait√©s');
    console.log('üìä [orders.js] Nombre final de commandes:', orders.length);
    console.log('üì¶ [orders.js] Commandes r√©cup√©r√©es:', orders.map(order => ({
      id: order.id,
      orderNumber: order.orderNumber,
      status: order.status,
      userId: order.userId,
      total: order.total
    })));
    console.log('üéâüéâüéâ [orders.js] ===== FIN getUserOrders =====');
    
    return orders;
  } catch (error) {
    console.error('üí•üí•üí• [orders.js] ===== ERREUR getUserOrders =====');
    console.error('‚ùå [orders.js] Erreur lors de la r√©cup√©ration des commandes utilisateur:', error);
    console.error('‚ùå [orders.js] Type d\'erreur:', typeof error);
    console.error('‚ùå [orders.js] Message d\'erreur:', error?.message);
    console.error('‚ùå [orders.js] Code d\'erreur:', error?.code);
    console.error('‚ùå [orders.js] Stack trace:', error?.stack);
    console.error('üí•üí•üí• [orders.js] ===== FIN ERREUR getUserOrders =====');
    throw error;
  }
};

// Mettre √† jour le statut d'une commande
import { addNotification } from './database.js';
export const updateOrderStatus = async (orderId, newStatus) => {
  // Log l'utilisateur Firebase courant
  try {
    const { getAuth } = await import('firebase/auth');
    const auth = getAuth();
    const currentUser = auth.currentUser;
    if (currentUser) {
      console.log('[orders.js] Utilisateur Firebase courant:', {
        uid: currentUser.uid,
        email: currentUser.email
      });
    } else {
      console.warn('[orders.js] Aucun utilisateur Firebase authentifi√© au moment de l\'update');
    }
  } catch (e) {
    console.warn('[orders.js] Erreur lors du log de l\'utilisateur Firebase courant:', e);
  }
  try {
    console.log('üîÑ [orders.js] Mise √† jour du statut de la commande:', orderId, 'vers:', newStatus);
    const orderRef = doc(db, 'orders', orderId);
    // Lire le document avant la mise √† jour pour debug
    const snap = await getDoc(orderRef);
    let prevOrder = {};
    if (snap.exists()) {
      prevOrder = snap.data();
      console.log('[orders.js] Document avant update:', prevOrder);
      console.log('[orders.js] userId dans le document:', prevOrder.userId);
    } else {
      console.warn('[orders.js] Document non trouv√© pour orderId:', orderId);
    }
    // Si newStatus est un objet, on merge ses champs, sinon on met √† jour le champ 'status'
    let updateFields = {};
    if (typeof newStatus === 'object' && newStatus !== null) {
      updateFields = { ...newStatus };
    } else {
      updateFields = { status: newStatus };
    }
    updateFields.updatedAt = new Date();
    await updateDoc(orderRef, updateFields);
    console.log('‚úÖ [orders.js] Statut de la commande mis √† jour');

    // Notification logique d√©plac√©e ici
    // R√©cup√©rer la commande mise √† jour
    const updatedSnap = await getDoc(orderRef);
    if (updatedSnap.exists()) {
      const order = updatedSnap.data();
      // Notification pour changement de niveau
      if (updateFields.niveau && updateFields.niveau !== prevOrder.niveau) {
        const notif = {
          userId: order.userId,
          orderId: orderId,
          title: 'Niveau de commande mis √† jour',
          message: `Le niveau de votre commande a √©t√© chang√© en : ${updateFields.niveau}`,
          createdAt: new Date(),
          read: false
        };
        console.log('[NOTIF][orders.js] Tentative cr√©ation notification NIVEAU:', notif);
        try {
          await addNotification(notif);
          console.log('[NOTIF][orders.js] Notification NIVEAU cr√©√©e avec succ√®s !');
        } catch (notifErr) {
          console.error('[NOTIF][orders.js] Erreur cr√©ation notification NIVEAU:', notifErr);
        }
      }
      // Notification pour changement de statut
      if (updateFields.status && updateFields.status !== prevOrder.status) {
        const notif = {
          userId: order.userId,
          orderId: orderId,
          title: 'Statut de commande mis √† jour',
          message: `Le statut de votre commande a √©t√© chang√© en : ${updateFields.status}`,
          createdAt: new Date(),
          read: false
        };
        console.log('[NOTIF][orders.js] Tentative cr√©ation notification STATUT:', notif);
        try {
          await addNotification(notif);
          console.log('[NOTIF][orders.js] Notification STATUT cr√©√©e avec succ√®s !');
        } catch (notifErr) {
          console.error('[NOTIF][orders.js] Erreur cr√©ation notification STATUT:', notifErr);
        }
      }
    }
    return true;
  } catch (error) {
    console.error('‚ùå [orders.js] Erreur lors de la mise √† jour du statut:', error);
    throw error;
  }
};

// Supprimer une commande
export const deleteOrder = async (orderId) => {
  try {
    console.log('üóëÔ∏è [orders.js] Suppression de la commande:', orderId);
    await deleteDoc(doc(db, 'orders', orderId));
    console.log('‚úÖ [orders.js] Commande supprim√©e');
    return true;
  } catch (error) {
    console.error('‚ùå [orders.js] Erreur lors de la suppression de la commande:', error);
    throw error;
  }
};